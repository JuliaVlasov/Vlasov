var documenterSearchIndex = {"docs":
[{"location":"vlasov-poisson/#Vlasov-Poisson","page":"Vlasov-Poisson","title":"Vlasov-Poisson","text":"","category":"section"},{"location":"vlasov-poisson/","page":"Vlasov-Poisson","title":"Vlasov-Poisson","text":"We consider the dimensionless Vlasov-Poisson equation for one species with a neutralizing background.","category":"page"},{"location":"vlasov-poisson/","page":"Vlasov-Poisson","title":"Vlasov-Poisson","text":"fracpartial fpartial t+ vcdot nabla_x f + E(tx) cdot nabla_v f = 0","category":"page"},{"location":"vlasov-poisson/","page":"Vlasov-Poisson","title":"Vlasov-Poisson","text":"- Delta phi = 1 - rho E = - nabla phi","category":"page"},{"location":"vlasov-poisson/","page":"Vlasov-Poisson","title":"Vlasov-Poisson","text":"rho(tx)  =  int f(txv)dv","category":"page"},{"location":"vlasov-poisson/","page":"Vlasov-Poisson","title":"Vlasov-Poisson","text":"Vlasov Equation - Wikipedia","category":"page"},{"location":"vlasov-poisson/","page":"Vlasov-Poisson","title":"Vlasov-Poisson","text":"using Plots","category":"page"},{"location":"vlasov-poisson/#Input-parameters","page":"Vlasov-Poisson","title":"Input parameters","text":"","category":"section"},{"location":"vlasov-poisson/","page":"Vlasov-Poisson","title":"Vlasov-Poisson","text":"using VlasovSolvers\n\ndev = CPU()                  # device\nnx, nv = 64, 64              # grid resolution\nstepper = StrangSplitting()  # timestepper\ndt = 0.1                     # timestep\nnsteps = 1000                # total number of time-steps\n\nxmin, xmax = 0, 4π           # X Domain length (m)\nvmin, vmax = -6, 6           # V Domain length (m)\nα  = 0.001                   # Perturbation amplitude\nkx = 0.5                     # Wave number of perturbation","category":"page"},{"location":"vlasov-poisson/#Simulation","page":"Vlasov-Poisson","title":"Simulation","text":"","category":"section"},{"location":"vlasov-poisson/","page":"Vlasov-Poisson","title":"Vlasov-Poisson","text":"xgrid = OneDGrid(dev, nx, xmin, xmax)\nvgrid = OneDGrid(dev, nv, vmin, vmax)\n\nf = DistributionFunction( xgrid, vgrid )\n\nlandau!(f, α, kx)\n\nprob = VlasovProblem(f, BSLSpline(5), dev)\n\nsol = solve!(prob, stepper, dt, nsteps )\n\nt = LinRange(0,100,1000)\n\nplot( t, sol; label = \"E\")\nplot!(t, -0.1533*t.-5.50; label=\"-0.1533t.-5.5\")","category":"page"},{"location":"contents/#Contents","page":"Contents","title":"Contents","text":"","category":"section"},{"location":"contents/","page":"Contents","title":"Contents","text":"","category":"page"},{"location":"contents/#Index","page":"Contents","title":"Index","text":"","category":"section"},{"location":"contents/","page":"Contents","title":"Contents","text":"","category":"page"},{"location":"vlasov-ampere/#Vlasov–Ampere","page":"Vlasov-Ampere","title":"Vlasov–Ampere","text":"","category":"section"},{"location":"vlasov-ampere/","page":"Vlasov-Ampere","title":"Vlasov-Ampere","text":"fracpartial fpartial t + upsilon fracpartial fpartial x\n- E(tx) fracpartial fpartial upsilon = 0","category":"page"},{"location":"vlasov-ampere/","page":"Vlasov-Ampere","title":"Vlasov-Ampere","text":"fracpartial Epartial t = - J = int fupsilon  dupsilon","category":"page"},{"location":"vlasov-ampere/#Algorithm","page":"Vlasov-Ampere","title":"Algorithm","text":"","category":"section"},{"location":"vlasov-ampere/","page":"Vlasov-Ampere","title":"Vlasov-Ampere","text":"For each j compute discrete Fourier transform in x of f^n(x_iupsilon_j) yielding f_k^n(upsilon_j), \nFor $ k \\neq 0 $\nCompute \nf^n+1_k(upsilon_j) = e^2ipi k upsilon Delta tL f_n^k(upsilon_j)\nCompute \nrho_k^n+1 = Delta upsilon sum_j f^n+1_k(upsilon_j)\nCompute\nE^n+1_k = rho^n+1_k L(2ipi k epsilon_0)\nFor k = 0 do nothing: \nf_n+1(upsilon_j) = f^n_k(upsilon_j) E^n+1_k = E^n_k.\nPerform inverse discrete Fourier transform of E^n+1_k and for each j of f^n+1_k (upsilon_j).","category":"page"},{"location":"vlasov-ampere/","page":"Vlasov-Ampere","title":"Vlasov-Ampere","text":"using Plots\nusing VlasovSolvers\n\ndev = CPU()                  # device\nnx, nv = 256, 256            # grid resolution\nstepper = StrangSplitting()  # timestepper\ndt = 0.01                    # timestep\nnsteps = 10                  # total number of time-steps\n\nxmin, xmax = 0, 4π           # X Domain length (m)\nvmin, vmax = -6, 6           # V Domain length (m)\nα  = 0.001                   # Perturbation amplitude\nkx = 0.5                     # Wave number of perturbation\n\nxgrid = OneDGrid(dev, nx, xmin, xmax)\nvgrid = OneDGrid(dev, nv, vmin, vmax)\n\nf = DistributionFunction( xgrid, vgrid )\n\nlandau!(f, α, kx)\n\nprob = VlasovProblem(f, Fourier(xgrid, vgrid), dev)\n\nnsteps = 600\ndt = 0.1\n\nsol = solve!(prob, stepper, dt, nsteps )\n\nt =  range(0,stop=60,length=nsteps)\n\nplot(t, -0.1533*t.-5.48)\nplot!(t, sol, label=\"ampere\" )","category":"page"},{"location":"bump_on_tail/#Bump-On-Tail","page":"Bump On Tail","title":"Bump On Tail","text":"","category":"section"},{"location":"bump_on_tail/","page":"Bump On Tail","title":"Bump On Tail","text":"using VlasovSolvers\nusing Plots\nusing LaTeXStrings","category":"page"},{"location":"bump_on_tail/","page":"Bump On Tail","title":"Bump On Tail","text":"\ndev = CPU()                  # device\nstepper = StrangSplitting()  # timestepper\ndt = 0.1                     # timestep\nnsteps = 1000                # total number of time-steps\n\nα   = 0.03\nkx  = 0.3\n\nn1, n2 = 32, 64\nx1min, x1max = 0.0, 2π / kx\nx2min, x2max = -9., 9.\n\nmesh1 = OneDGrid(dev, n1, x1min, x1max)\nmesh2 = OneDGrid(dev, n2, x2min, x2max)\n\nf = DistributionFunction( mesh1, mesh2 )\n\n\nfor (i,x) in enumerate(mesh1.points), (j,v) in enumerate(mesh2.points)\n    f.values[i,j]  = (1.0+α*cos(kx*x)) / (10*sqrt(2π)) * (9*exp(-0.5*v^2)+2*exp(-2*(v-4.5)^2))\nend\n","category":"page"},{"location":"bump_on_tail/","page":"Bump On Tail","title":"Bump On Tail","text":"nsteps = 500\nt   = range(0.0, stop=50.0, length=nsteps)\ndt  = t[2]\n\nprob = VlasovProblem(f, BSLSpline(5), dev)\n\nsol = solve!(prob, stepper, dt, nsteps )","category":"page"},{"location":"bump_on_tail/","page":"Bump On Tail","title":"Bump On Tail","text":"plot(t, sol, label=L\"\\frac{1}{2} \\log(∫e²dx)\")","category":"page"},{"location":"#VlasovSolvers.jl-Documentation","page":"Home","title":"VlasovSolvers.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"First draft of a Vlasov solvers Julia suite.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Backward Semi-Lagrangian\nPseudo-Spectral\nParticle-In-Cell","category":"page"},{"location":"#Types-and-functions","page":"Home","title":"Types and functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [VlasovSolvers]\nOrder   = [:type, :function]","category":"page"},{"location":"#VlasovSolvers.advection!-Tuple{Array{AbstractFloat,2},OneDGrid,Any,Any}","page":"Home","title":"VlasovSolvers.advection!","text":"advection_v!(f, dt)\n\nfunction to advect the distribution function f with velocity v during a time step dt. Interpolation method uses bspline periodic.\n\n\n\n\n\n","category":"method"},{"location":"#VlasovSolvers.bspline-Tuple{Int64,Int64,Float64}","page":"Home","title":"VlasovSolvers.bspline","text":"bspline(p, j, x)\n\nReturn the value at x in [0,1[ of the B-spline with integer nodes of degree p with support starting at j. Implemented recursively using the De Boor's Algorithm\n\nB_i0(x) = left\nbeginmatrix\n1  mathrmif  quad t_i  x  t_i+1 \n0  mathrmotherwise \nendmatrix\nright\n\nB_ip(x) = fracx - t_it_i+p - t_i B_ip-1(x) \n+ fract_i+p+1 - xt_i+p+1 - t_i+1 B_i+1p-1(x)\n\n\n\n\n\n","category":"method"},{"location":"#VlasovSolvers.compute_e-Tuple{DistributionFunction}","page":"Home","title":"VlasovSolvers.compute_e","text":"compute_e(f)\n\ncompute Ex using that -ik*Ex = rho \n\n\n\n\n\n","category":"method"},{"location":"#VlasovSolvers.compute_rho-Tuple{DistributionFunction}","page":"Home","title":"VlasovSolvers.compute_rho","text":"compute_rho(f)\n\nCompute charge density ρ(x,t) = ∫ f(x,v,t) dv\n\n\n\n\n\n","category":"method"},{"location":"rotation2d/#Rotation-of-a-gaussian-distribution","page":"Rotation 2D","title":"Rotation of a gaussian distribution","text":"","category":"section"},{"location":"rotation2d/","page":"Rotation 2D","title":"Rotation 2D","text":"fracdfdt +  (y fracdfdx - x fracdfdy) = 0","category":"page"},{"location":"rotation2d/","page":"Rotation 2D","title":"Rotation 2D","text":"using Plots\nusing VlasovSolvers","category":"page"},{"location":"rotation2d/","page":"Rotation 2D","title":"Rotation 2D","text":"\ndev = GPU()\nn1, n2 = 256, 256\nmesh1 = OneDGrid(dev, n1, -pi, pi)\nmesh2 = OneDGrid(dev, n2, -pi, pi)\n\nx = mesh1.points\ny = mesh2.points\n\nnsteps = 1000\ntf = 200 * pi\ndt = tf/nsteps\n\nf = DistributionFunction( mesh1, mesh2 )\n\nfor (i, xp) in enumerate(x), (j, yp) in enumerate(y)\n    xn = cos(tf)*xp - sin(tf)*yp\n    yn = sin(tf)*xp + cos(tf)*yp\n    f.values[i,j] = exp(-(xn-1)*(xn-1)/0.2)*exp(-(yn-1)*(yn-1)/0.2)\nend\n","category":"page"},{"location":"vlasov-hmf/#Vlasov-HMF","page":"Vlasov-HMF","title":"Vlasov-HMF","text":"","category":"section"},{"location":"vlasov-hmf/","page":"Vlasov-HMF","title":"Vlasov-HMF","text":"using LinearAlgebra, QuadGK, Roots, FFTW\nusing VlasovSolvers\nusing Plots","category":"page"},{"location":"vlasov-hmf/","page":"Vlasov-HMF","title":"Vlasov-HMF","text":"\" Compute M₀ by solving F(m) = 0 \"\nfunction mag(β, mass)\n\n    F(m) = begin\n        g(x, n, m) = (1 / π) * (exp(β * m * cos(x)) * cos(n * x))\n        bessel0(x) = g(x, 0, m)\n        bessel1(x) = g(x, 1, m)\n        mass * quadgk(bessel1, 0, π)[1] / quadgk(bessel0, 0, π)[1] - m\n    end\n\n    find_zero(F, (0, mass))\nend","category":"page"},{"location":"vlasov-hmf/","page":"Vlasov-HMF","title":"Vlasov-HMF","text":"function Norm(f::Array{Float64,2}, delta1, delta2)\n   return delta1 * sum(delta2 * sum(real(f), dims=1))\nend","category":"page"},{"location":"vlasov-hmf/","page":"Vlasov-HMF","title":"Vlasov-HMF","text":"\"\"\"\n    hmf_poisson!(fᵗ    :: Array{Complex{Float64},2},\n                 mesh1 :: OneDGrid,\n                 mesh2 :: OneDGrid,\n                 ex    :: Array{Float64})\n\n    Compute the electric hamiltonian mean field from the\n    transposed distribution function\n\n\"\"\"\nfunction hmf_poisson!(fᵗ::Array{Complex{Float64},2},\n        mesh1::OneDGrid,\n        mesh2::OneDGrid,\n        ex::Array{Float64})\n\n    n1 = mesh1.len\n    rho = mesh2.step .* vec(sum(fᵗ, dims=1))\n    kernel = zeros(Float64, n1)\n    k = π / (mesh1.stop - mesh1.start)\n    kernel[2] = k\n    ex .= real(ifft(1im * fft(rho) .* kernel * 4π ))\n\nend","category":"page"},{"location":"vlasov-hmf/","page":"Vlasov-HMF","title":"Vlasov-HMF","text":"dev = CPU()\nnsteps = 10000\ndt = 0.1\n\nmass = 1.0\nT = 0.1\nmesh1 = OneDGrid(dev, 64, -π, π)\nmesh2 = OneDGrid(dev, 64, -8, 8)\n\nn1, delta1 = mesh1.len, mesh1.step\nn2, delta2 = mesh2.len, mesh2.step\nx, v = mesh1.points, transpose(mesh2.points)\nϵ = 0.1\n\nb = 1 / T\nm = mag(b, mass)\n\nw   = sqrt(m)\nf   = zeros(Complex{Float64}, (n1,n2))\nfᵗ  = zeros(Complex{Float64}, (n2,n1))\n\nf  .= exp.(-b .* ((v.^2 / 2) .- m .* cos.(x)))","category":"page"},{"location":"vlasov-hmf/","page":"Vlasov-HMF","title":"Vlasov-HMF","text":"a   = mass / Norm(real(f), delta1, delta2)\n@.  f =  a * exp(-b * (((v^2) / 2) - m * cos(x))) * (1 + ϵ * cos(x))\n\nex = zeros(Float64,n1)\nhmf_poisson!(f, mesh1, mesh2, ex )\ntest = copy(f)\nT = Float64[]\n\nfor n in 1:nsteps\n\n    gamma1 = Norm(real(f) .* cos.(x), delta1, delta2)\n    push!(T,gamma1)\n\n    ### Here compute f...\n\nend\n\n#Substracting from gamma its long time average\n\nGamma1 = Norm(real(f) .* cos.(x), delta1, delta2)\n\nT .= T .- Gamma1\n\nt = range(0., stop=nsteps*dt, length=nsteps) |> collect\nT .= abs.(T)\n\nplot(t, log.(T), xlabel = \"t\", ylabel = \"|C[f](t)-C[f][T]|\")","category":"page"}]
}
